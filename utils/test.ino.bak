#include "waveshare_lcd_port.h"
#include <esp_display_panel.hpp>

using namespace esp_panel::drivers;

// Variabile globale per il display
esp_panel::drivers::LCD* display = nullptr;

// Buffer per l'immagine (width * height * 2 bytes per RGB565)
uint16_t* imageBuffer = nullptr;

// Funzione per ottenere il colore RGB565
uint16_t rgb565(uint8_t r, uint8_t g, uint8_t b) {
    return ((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3);
}

// Funzione per impostare un pixel nel buffer
void setPixelInBuffer(uint16_t* buffer, int x, int y, uint16_t color) {
    if (x >= 0 && x < EXAMPLE_LCD_WIDTH && y >= 0 && y < EXAMPLE_LCD_HEIGHT) {
        buffer[y * EXAMPLE_LCD_WIDTH + x] = color;
    }
}

// Funzione per disegnare un rettangolo pieno nel buffer
void drawFilledRectInBuffer(uint16_t* buffer, int x, int y, int width, int height, uint16_t color) {
    for (int i = 0; i < height; i++) {
        for (int j = 0; j < width; j++) {
            setPixelInBuffer(buffer, x + j, y + i, color);
        }
    }
}

// Funzione per disegnare un cerchio nel buffer
void drawCircleInBuffer(uint16_t* buffer, int centerX, int centerY, int radius, uint16_t color) {
    for (int y = -radius; y <= radius; y++) {
        for (int x = -radius; x <= radius; x++) {
            if (x*x + y*y <= radius*radius) {
                setPixelInBuffer(buffer, centerX + x, centerY + y, color);
            }
        }
    }
}

// Funzione per riempire tutto il buffer con un colore
void fillBuffer(uint16_t* buffer, uint16_t color) {
    for (int i = 0; i < EXAMPLE_LCD_WIDTH * EXAMPLE_LCD_HEIGHT; i++) {
        buffer[i] = color;
    }
}

// Funzione per disegnare una immagine di test
void drawTestImage(esp_panel::drivers::LCD* lcd) {
    Serial.println("Disegnando immagine di test...");
    
    // Alloca memoria per il buffer dell'immagine
    if (imageBuffer == nullptr) {
        imageBuffer = (uint16_t*)malloc(EXAMPLE_LCD_WIDTH * EXAMPLE_LCD_HEIGHT * sizeof(uint16_t));
        if (imageBuffer == nullptr) {
            Serial.println("ERRORE: Impossibile allocare memoria per il buffer dell'immagine");
            return;
        }
    }
    
    // Prima mostra le barre colorate di test
    lcd->colorBarTest();
    delay(2000);
    
    // Riempi il buffer con sfondo blu scuro
    uint16_t bgColor = rgb565(0, 0, 50);
    fillBuffer(imageBuffer, bgColor);
    
    Serial.println("Sfondo completato");
    
    // Disegna alcuni rettangoli colorati
    drawFilledRectInBuffer(imageBuffer, 50, 50, 200, 100, rgb565(255, 0, 0));   // Rosso
    drawFilledRectInBuffer(imageBuffer, 300, 50, 200, 100, rgb565(0, 255, 0));  // Verde  
    drawFilledRectInBuffer(imageBuffer, 550, 50, 200, 100, rgb565(0, 0, 255));  // Blu
    
    Serial.println("Rettangoli completati");
    
    // Disegna alcuni cerchi
    drawCircleInBuffer(imageBuffer, 150, 300, 80, rgb565(255, 255, 0));   // Giallo
    drawCircleInBuffer(imageBuffer, 400, 300, 80, rgb565(255, 0, 255));   // Magenta
    drawCircleInBuffer(imageBuffer, 650, 300, 80, rgb565(0, 255, 255));   // Ciano
    
    Serial.println("Cerchi completati");
    
    // Disegna una griglia di punti bianchi
    for (int y = 400; y < 500; y += 20) {
        for (int x = 100; x < 800; x += 20) {
            drawFilledRectInBuffer(imageBuffer, x, y, 5, 5, rgb565(255, 255, 255));
        }
    }
    
    Serial.println("Griglia completata");
    
    // Disegna il testo "TEST" usando pixel (forma molto semplice)
    // Lettera T
    drawFilledRectInBuffer(imageBuffer, 100, 520, 60, 10, rgb565(255, 255, 255));
    drawFilledRectInBuffer(imageBuffer, 125, 520, 10, 50, rgb565(255, 255, 255));
    
    // Lettera E
    drawFilledRectInBuffer(imageBuffer, 180, 520, 10, 50, rgb565(255, 255, 255));
    drawFilledRectInBuffer(imageBuffer, 180, 520, 40, 10, rgb565(255, 255, 255));
    drawFilledRectInBuffer(imageBuffer, 180, 545, 30, 10, rgb565(255, 255, 255));
    drawFilledRectInBuffer(imageBuffer, 180, 570, 40, 10, rgb565(255, 255, 255));
    
    // Lettera S
    drawFilledRectInBuffer(imageBuffer, 240, 520, 40, 10, rgb565(255, 255, 255));
    drawFilledRectInBuffer(imageBuffer, 240, 520, 10, 25, rgb565(255, 255, 255));
    drawFilledRectInBuffer(imageBuffer, 240, 545, 40, 10, rgb565(255, 255, 255));
    drawFilledRectInBuffer(imageBuffer, 270, 545, 10, 25, rgb565(255, 255, 255));
    drawFilledRectInBuffer(imageBuffer, 240, 570, 40, 10, rgb565(255, 255, 255));
    
    // Lettera T
    drawFilledRectInBuffer(imageBuffer, 300, 520, 60, 10, rgb565(255, 255, 255));
    drawFilledRectInBuffer(imageBuffer, 325, 520, 10, 50, rgb565(255, 255, 255));
    
    Serial.println("Buffer immagine completato, invio al display...");
    
    // Invia il buffer al display usando drawBitmap
    lcd->drawBitmap(0, 0, EXAMPLE_LCD_WIDTH, EXAMPLE_LCD_HEIGHT, (uint8_t*)imageBuffer);
    
    Serial.println("Immagine di test completata!");
}

void setup()
{
    Serial.begin(115200); // Initialize serial communication at 115200 baud rate
    Serial.println("RGB LCD example start"); // Print start message for RGB LCD example
    
    // Inizializza il display e ottieni il puntatore
    display = waveshare_lcd_init_and_get(); // Initialize the RGB LCD
    
    if (display != nullptr) {
        Serial.println("Display inizializzato correttamente");
        
        // Aspetta un po' prima di disegnare
        delay(1000);
        
        // Disegna l'immagine di test
        drawTestImage(display);
    } else {
        Serial.println("ERRORE: Impossibile inizializzare il display");
    }
    
    Serial.println("RGB LCD example end"); // Print end message for RGB LCD example
}

void loop()
{
    delay(5000); // Wait for 5 seconds
    Serial.println("IDLE loop - Display test image is shown"); // Print idle loop message
    
    // Opzionalmente puoi aggiungere animazioni o cambiare l'immagine qui
}
